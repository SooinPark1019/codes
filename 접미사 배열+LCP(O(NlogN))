string S;
int N, sa[MAX], pos[MAX], lcp[MAX];
int cnt[MAX+1] = {0};

struct SuffixNode{
    int sa;
    P rank;
    bool operator <(const SuffixNode &O)const{ return rank < O.rank; }
};

SuffixNode node[MAX], nodeTemp[MAX];

void constructSA() {
    N = S.length();
    for (int i = 0; i < N; i++) {
        node[i].sa = i;
        node[i].rank = P(S[i] - 'a', i + 1 < N ? S[i + 1] - 'a' : -1);
    }

    sort(node, node + N);

    for (int d = 2; d < N; d *= 2) {
        int rank = 0;
        int prevRank = node[0].rank.first;
        node[0].rank.first = rank;
        pos[node[0].sa] = 0;

        for (int i = 1; i < N; i++) {
            if (node[i].rank == P(prevRank, node[i - 1].rank.second)) {
                node[i].rank.first = rank;
            } else {
                prevRank = node[i].rank.first;
                node[i].rank.first = ++rank;
            }
            pos[node[i].sa] = i;
        }

        for (int i = 0; i < N; i++) {
            int nextIndex = node[i].sa + d;
            node[i].rank.second = nextIndex < N ? node[pos[nextIndex]].rank.first : -1;
        }

        sort(node, node + N);
    }

    for (int i = 0; i < N; i++) {
        sa[i] = node[i].sa;
    }
}
 
void constructLCP(){
    for(int i=0, k=0; i<N; i++, k=max(k-1, 0)){
        if(pos[i] == N-1) continue;
        for(int j=sa[pos[i]+1]; S[i+k]==S[j+k]; k++);
        lcp[pos[i]] = k;
    }
}
